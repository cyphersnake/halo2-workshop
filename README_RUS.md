# halo2-quickstart-workshop

## Зачем и для кого эта статья
Почти все учебные материалы по написанию circuit сделаны для математиков и про математику. Однако цель данной статьи — помочь Rust-разработчикам, которые понимают математику над полем и в целом могут разобраться в том, как работает хэш-функция, освоить основы разработки zero-knowledge proof (zkp) схем (circuit). Мы хотим показать, что zk — это не сплошной Rocket Science, и разрушить страх у новичков перед этой технологией.

В индустрии существует острый кадровый голод в области zk. Новеньких нанимают неохотно, а большинство кандидатов имеют PhD в криптографии, но средние навыки программирования. Мы считаем, что привлечение новых людей в индустрию позволит ей расти быстрее.

В этой статье мы шаг за шагом рассмотрим, как решить конкретную задачу — проверку сбалансированности скобок в строке — с помощью zk-схемы на основе halo2 и PLONKish арифметизации.

# Что такое zkp
На самом деле, zero-knowledge proof (zkp) — это всего лишь одно из свойств относительно новых криптографических протоколов из области [programmable cryptography](https://0xparc.org/blog/programmable-cryptography-1).

Даже в таком случае, это не один тип проектов, а несколько:

- Криптографические протоколы
- Сопутствующие фреймворки и библиотеки
- Circuit (схемы)
- Интеграция и оптимизация всего вышеобозначенного

Каждый тип проектов требует своего набора знаний. Большая часть рынка — это последние два пункта, которые относительно простые задачи. Но, к сожалению, инструментарий еще далек от совершенства, и базу знать надо, чтобы все не сломать.

Рекомендуем для начала:

- [zk-learning](https://zk-learning.org/) Если первая лекция "Introduction and History of ZKP" будет идти тяжело, можете пропустить; она носит общеобразовательный характер.
- ["A friendly introduction to zero-knowledge"](https://zkintro.com/articles/friendly-introduction-to-zero-knowledge)
- Для совсем новичков в криптографии рекомендуем книгу ["Real-World Cryptography"](https://www.manning.com/books/real-world-cryptography). Она позволит выявить сложные для понимания места и создать необходимую основу для дальнейшего изучения.

Совет: Используйте LLM (например, с помощью [простого промпта](https://chat.openai.com/g/g-vs6wmhNRY-zkp-copilot)) как второго пилота в обучении. С большими и комплексными задачами он не справится, а вот с маленькими и локальными (например, "объясни мне этот термин в контексте этого протокола") он очень даже хорош.

# Что такое circuit

Circuit — это то, что можно доказать с помощью криптографических протоколов. Разработка подобных проектов является самой частой работой, которую можно найти в домене zk. 

Задача при разработке circuit состоит в том, чтобы описать алгоритм с помощью фреймворка и провалидировать переходы в вычислениях. Схема получает на вход публичные и приватные сигналы. Приватные сигналы известны только тому, кто создает доказательство.

### Пример
Возьмем простой пример — знание множителей числа: $a×b=c$. В этом примере $c$ будет публичным входом, так как его будут знать все, $а$ и $b$ будут приватными.

Каждый фреймворк описывает это по-разному. Возьмем самый популярный DSL — Circom:

```circom
pragma circom 2.0.0;

template Multiplier2 () {
   signal input a;
   signal input b;
   signal output c;

   c <== a * b;
}
component main = Multiplier2();
```

Это все! Алиса запускает этот код, он производит доказательство, а Боб может проверить доказательство, не зная $a$ и $b$.

## {on, off}-circuit

Используя DSL, сложнее совершить ошибку: у вас мало шансов сделать какой-либо логический переход без доказательств. Однако в более широком поле инструментов у вас есть {on, off}-circuit. Вычисления могут быть доказываемыми и совершаемыми вне доказательств.

#### Пример

Задача: 
$a×b  mod  N = c$ где $N$ большое простое число

Может показаться, что нужно выполнять модульные операции внутри circuit. Однако правильнее разделить числа обычным способом, получить соотношение $a×b=r×N+c$ и on-circuit доказать только это равенство, что проще и мало отличается от предыдущего примера.

### Выводы
Рекомендуем попробовать [Circom](https://docs.circom.io/getting-started/installation/) и посмотреть простые примеры. Это самый простой способ начать работать с zkp.

## Что такое halo2?
[halo2](https://github.com/zcash/halo2) — это библиотека и фреймворк для создания zk-схем на основе PLONKish арифметизации. Он позволяет описывать сложные вычисления и доказывать их корректность без раскрытия приватных данных. В отличие от некоторых DSL, halo2 предоставляет более гибкий и мощный инструментарий, но требует более глубокого понимания математики и криптографии.

## Что такое арифметизация PLONKish
Когда речь идет о halo2, мы используем [PLONKish арифметизацию](https://zcash.github.io/halo2/concepts/arithmetization.html).

В ее рамках у нас есть матрица над полем (каждый элемент матрицы — элемент конечного поля над простым числом), в которой мы:

Имеем колонки трех типов:
- Fixed — неизменные константы.
- Instance — сигналы внутрь circuit (передаваемые извне в схему).
- Advice — зависящие от сигнала значения.

Задаем отношения колонок друг к другу (Gates):
- Например, "5-я колонка плюс 4-я колонка минус 9-я колонка должно получиться 0".

Задаем допустимые значения для некоторого отношения над колонками (Lookup):
- Например, "5-я колонка плюс 4-я колонка минус 9-я колонка должно получиться что-то из 1-й колонки".

Говорим, что некоторые ячейки должны быть равны друг другу (Copy-constraint):
- Единственный тип отношений не между колонками, а между ячейками.

Все инструменты, кроме последнего, применяются на первом этапе конфигурации схемы. Чем меньше колонок, gates и lookup аргументов, тем лучше, однако их число варьируется от проекта к проекту. Можно расти в ширь, добавляя колонки, а можно вниз, стараясь минимизировать число отношений над колонками. Все это влияет на разные параметры финального решения. Таким образом, арифметизация — краеугольная тема для разработки circuit.

Итогово, ваша задача — выразить целевой алгоритм как совокупность отношений, представленных с помощью инструментов выше. Проще говоря, каждая строка матрицы — кусок вычислений, а сами вычисления задаются на колонках.

## Какую задачу мы будем решать и почему?

Мы решили взять небольшую, но исходно не математическую проблему: **проверку сбалансированности скобок в строке**. Задача включает в себя формулирование арифметизации, реализацию и тесты.

### Почему именно эту задачу?

Почти все учебные материалы по написанию circuit сделаны для математиков и про математику. Здесь же мы хотим показать, что можно решать практические задачи, не связанные напрямую с математикой, и научить разработчиков использовать zk-технологии для решения реальных проблем.

Хотя конкретна эта задача синтетическая, но легко представить подобный circuit для доказательства криптостойкости пароля, без раскрытия пароля. 

## Решение (Арифметизация)

## Алгоритм
Рассмотрим простое решение на Rust:

```rust
fn is_valid_brackets(s: &str) -> bool {
    s.chars()
        .try_fold(0u32, |acc, c| match c {
            '(' => Some(acc + 1),
            ')' => acc.checked_sub(1),
            other => panic!("not allowed symbol: {other}"),
        })
        .eq(&Some(0))
}

fn main() {
    assert!(is_valid_brackets("()"));
    assert!(!is_valid_brackets(")("));
}
```

### Математическое представление
Нам нужно представить этот алгоритм через инструменты PLONKish арифметизации.

1. Проверка допустимых символов: Нужно провалидировать, что вход состоит только из допустимых ASCII кодов: 40 для '(', 41 для ')'.
2. Преобразование символов: Нужна функция $f(x)$, которая преобразует 40 и 41 в 1 и -1 соответственно.
3. Суммирование: Нужно просуммировать все значения и проверить, что сумма равна 0: $∑f(x_i)=0$.
4. Проверка неперехода через ноль: Нужно убедиться, что аккумулятор (число открытых скобок) не становится отрицательным на любом шаге (иначе последовательность типа ')(' прошла бы проверку).

## Решение шаг за шагом
### 1. Проверка допустимых символов
Используем lookup таблицу. Копируем входной сигнал и проверяем, что он входит в таблицу, где заполнены только два константных значения: 40 и 41.

### 2. Преобразование символов
Нам нужна функция $f(x)$, которая для $x=40$ дает $1$, а для $x=41$ дает $-1$.

**Решение**:
Для решения подобной задачи есть [многочлен Лагранджа](https://ru.wikipedia.org/wiki/%D0%98%D0%BD%D1%82%D0%B5%D1%80%D0%BF%D0%BE%D0%BB%D1%8F%D1%86%D0%B8%D0%BE%D0%BD%D0%BD%D1%8B%D0%B9_%D0%BC%D0%BD%D0%BE%D0%B3%D0%BE%D1%87%D0%BB%D0%B5%D0%BD_%D0%9B%D0%B0%D0%B3%D1%80%D0%B0%D0%BD%D0%B6%D0%B0), однако, так как данный материал для разработчиков, я могу посоветовать им просто спросить об этом [Wolfram GPTs](https://chatgpt.com/g/g-0S5FXLyFN-wolfram), который не просто подскажет как искать его, но и сделает все за вас.

Используем полином: $f(x)=81−2x$

Проверяем:
- $f(40)=81−2×40=1$
- $f(41)=81−2×41=−1$

### 3. Суммирование
Можно создать множество колонок и сделать все за одну строку или взять пару колонок и сделать за множество строк. В общем случае, лучше расти вниз (больше строк), чем вширь (больше колонок).

Структура колонок:
| a1      | a2                    |
| --      | --                    |
| x_i     | prev_val              |
| x_{i+1} | prev_val + 81 - 2*x_i |

Таким образом, мы получили сумму всех преобразованных значений в колонке аккумулятора. В конце сравниваем с нулем, и мы выполнили этот пункт.

### 4. Проверка неперехода через ноль
Работая в поле, у нас нет отрицательных чисел (отрицательное число $-k$ представлено как $p−k$, где $p$ — характеристика поля). Также нет возможности легко сделать сравнение "больше/меньше".

**Решение**:

В целом, нам просто нужно проверить равенство на $-1$ (ведь шаг всегда на единицу), поэтому прибавим $1$ и сравним результат с нулем. Назовем $x = acc + 1$

Дизайн ограничений будет относительно простой, хоть и многословный:

| a1      | a2          | gate1           |
| ------- | ----------- | --------------- |
| x       | x' = 1/x    | x * (1 - x * x')|

Это выражение проверяет, что в a2 колонке действительно находится 1/x (или что в x точно лежит 0)

| x   | x'        | Equation              |
| --- | -------   | ------------------    |
| 0   | 0         | 0 * (1 - 0 * 0)  == 0 |
| 5   | 1/5       | 5 * (1 - 5/5)    == 0 |
| 5   | x' != 1/5 | 5 * (1 - 5 * x') != 0 |
| 0   | 5         | 5 * (1 - 0 * 5)  == 0 |

Это дает, что выражение $1 - x * x' == 0$ только в случае, когда $x != 0$, значит добавим $gate2 = 1 - x * x' == 0$ и получим доказательство того, что внутри $x$ лежит не $0$.

$gate1$ для валидации $x' = 1/x$, 
$gate2$ для валидации $x == 0$ с учетом верности $gate1$

Теперь у нас есть полный набор ограничений, необходимых для реализации circuit.

### План реализации в коде
Мы планируем реализовать наше решение в коде, используя halo2. Для этого разделим реализацию на три шага:

#### 1. Решаем, в каком виде и как будем хранить приватный и публичный вход
1.1 Определяем, что является публичным и приватным входом.
1.2 Определяем крайние случаи для тестирования.

#### 2. Настройка ограничений
2.1 Выражаем gate/lookup, описанные в арифметизации, через `ConstraintSystem`.
2.2 Решаем, сколько у нас будет колонок и что в них будет лежать.
2.3 Реализуем Circuit::configure.

#### 3. Для конкретного входа заполняем ячейки таблицы
3.1 Ограничения, заданные ранее, не зависят от входа — это дизайн схемы.
3.2 Данные внутри таблицы, знание которых мы и доказываем, заполняются на этом этапе.
3.3 Реализуем Circuit::synthesize.

## Создаем проект:

```bash
cargo init --lib halo2-workshop
cd halo2-workshop
cargo add halo2_proofs
```

Добавляем в lib.ru заготовку кода:

```rust 
use std::marker::PhantomData;

use halo2_proofs::{
    circuit::{Layouter, SimpleFloorPlanner},
    pasta::group::ff::PrimeField,
    plonk::{Circuit, ConstraintSystem},
};

// Определяет сам circuit, а так же хранит внутри приватные входы для него
#[derive(Default)]
struct BracketCircuit<F: PrimeField> {
    _p: PhantomData<F>,
}

// Хранит информацию о конфигурации PLONKish таблицы: колонки, lookup таблицы
#[derive(Clone)]
struct Config {}

impl<F: PrimeField> Circuit<F> for BracketCircuit<F> {
    type Config = Config;

    // Игнорировать на данном этапе
    type FloorPlanner = SimpleFloorPlanner;

    // Игнорировать на данном этапе
    fn without_witnesses(&self) -> Self {
        todo!("Not needed at this stage.")
    }

    fn configure(_meta: &mut ConstraintSystem<F>) -> Self::Config {
        todo!(
            "Здесь задаются структура таблицы:
            - столбцы
            - gates (ограничения)
            - lookup-таблицы"
        )
    }

    fn synthesize(
        &self,
        _config: Self::Config,
        _layouter: impl Layouter<F>,
    ) -> Result<(), halo2_proofs::plonk::Error> {
        todo!("Здесь будут заполнены ячейки таблицы")
    }
}

#[cfg(test)]
mod tests {
    use halo2_proofs::{dev::MockProver, pasta::Fq};

    use super::*;

    #[test]
    fn simple() {
        // Встроенный вспомогательный тип для тестирования
        MockProver::run(
            1,                                // Размер таблицы, заданный как $log2(row_count)$
            &BracketCircuit::<Fq>::default(), // Экземпляр circuit
            vec![],                           // Публичные входы
        )
        .unwrap();
    }
}
```

Данный код можно так же найти по [этой ссылку](https://github.com/cyphersnake/halo2-workshop/blob/step-1/src/lib.rs).

### 1. Решаем, в каком виде и как будем хранить приватный и публичный вход

#### 1.1 Определяем, что является публичным и приватным входом.
В реальных сценариях, circuits без публичного входа достаточно редки, так как верификатор не знает, что конкретно он верифицирует, если только circuit не является строго специализированным и факт наличия доказательства уже дает информацию. 

Однако для нашей синтетической задачи, мы опустим публичных вход, сделав строку с скобками - приватным. 

Так же одной из особенностей разработки circuit является необходимость консистентной стркутуры таблицы, вне зависимости от входа. На практике это означает, что чтобы мы не передали на вход, во время синтеза мы должны заполнять одни и те же ячейки, в нашем случае - фиксировать размер входа. Лучше всего это делать на уровне типа `Circuit` структуры явным образом.

Как выразить это в коде? Мы должны добавить дженерик с размером входа и поле в `BracketCircuit`.

```rust
// Добавляем дженерик константу LEN - длинну входа
pub struct BracketCircuit<F: PrimeField, const LEN: usize> {
    // Добавляем поле `input`
    //
    // Делаем его массивом, чтобы дополнительно фиксировать гарантии размера
    input: [char; LEN],
    _p: PhantomData<F>,
}

impl<F: PrimeField, const LEN: usize> BracketCircuit<F, LEN> {
    // Как вы можете видеть, мы тут просто проверяем размерм
    pub fn try_new(input: impl AsRef<str>) -> Option<Self> {

        // Может возникнуть вопрос, почему мы не можем проверить корректность `input` 
        //     прямо тут. В рамках реальных приложений, так и происходит, ибо нет
        //     мотивации генерировать неверное доказательство, но нам такая возможность 
        //     нужна для тестов

        Some(Self {
            input: input.as_ref().chars().collect::<Vec<_>>().try_into().ok()?,
            _p: PhantomData,
        })
    }
}
```

#### 1.2 Определяем крайние случаи для тестирования.

Тут практически нет отличий от поиска крайних случаев для обычного императивного кода

##### Correct Cases
1. `""`
2. `"()"`
3. `"(()(())())"`
4. `"()()()"`

##### Error Expected Cases
1. `"())"`
2. `"(()"`
3. `"())("`
4. `"("`
5. `")"`
6. `"*"`

В коде это будет выглядеть следующим образом:

```rust
#[cfg(test)]
mod tests {
    use halo2_proofs::{dev::MockProver, pasta::Fp};

    use super::*;

    // Для валидных кейсов
    #[test]
    fn valid() {
        MockProver::run(
            10,
            &BracketCircuit::<Fp, 10>::try_new("(()(())())").unwrap(),
            vec![],
        )
        .unwrap()
        .verify()
        .unwrap();
    }

    // Для не валидных
    #[test]
    fn unvalid_order() {
        MockProver::run(10, &BracketCircuit::<Fp, 2>::try_new(")(").unwrap(), vec![])
            .unwrap()
            .verify()
            .unwrap_err();
    }
}
```

### 2. Настройка ограничений

#### 2.1 Выражаем gate/lookup, описанные в арифметизации, через `ConstraintSystem`.
