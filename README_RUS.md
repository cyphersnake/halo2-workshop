# halo2-quickstart-workshop

## Зачем и для кого эта статья
Почти все учебные материалы по написанию circuit сделаны для математиков и про математику. Однако цель данной статьи — помочь Rust-разработчикам, которые понимают математику над полем и в целом могут разобраться в том, как работает хэш-функция, освоить основы разработки zero-knowledge proof (zkp) схем (circuit). Мы хотим показать, что zk — это не сплошной Rocket Science, и разрушить страх у новичков перед этой технологией.

В индустрии существует острый кадровый голод в области zk. Новеньких нанимают неохотно, а большинство кандидатов имеют PhD в криптографии, но средние навыки программирования. Мы считаем, что привлечение новых людей в индустрию позволит ей расти быстрее.

В этой статье мы шаг за шагом рассмотрим, как решить конкретную задачу — проверку сбалансированности скобок в строке — с помощью zk-схемы на основе halo2 и PLONKish арифметизации.

# Что такое zkp
На самом деле, zero-knowledge proof (zkp) — это всего лишь одно из свойств относительно новых криптографических протоколов из области [programmable cryptography](https://0xparc.org/blog/programmable-cryptography-1).

Даже в таком случае, это не один тип проектов, а несколько:

- Криптографические протоколы
- Сопутствующие фреймворки и библиотеки
- Circuit (схемы)
- Интеграция и оптимизация всего вышеобозначенного

Каждый тип проектов требует своего набора знаний. Большая часть рынка — это последние два пункта, которые относительно простые задачи. Но, к сожалению, инструментарий еще далек от совершенства, и базу знать надо, чтобы все не сломать.

Рекомендуем для начала:

- [zk-learning](https://zk-learning.org/) Если первая лекция "Introduction and History of ZKP" будет идти тяжело, можете пропустить; она носит общеобразовательный характер.
- ["A friendly introduction to zero-knowledge"](https://zkintro.com/articles/friendly-introduction-to-zero-knowledge)
- Для совсем новичков в криптографии рекомендуем книгу ["Real-World Cryptography"](https://www.manning.com/books/real-world-cryptography). Она позволит выявить сложные для понимания места и создать необходимую основу для дальнейшего изучения.

Совет: Используйте LLM (например, с помощью [простого промпта](https://chat.openai.com/g/g-vs6wmhNRY-zkp-copilot)) как второго пилота в обучении. С большими и комплексными задачами он не справится, а вот с маленькими и локальными (например, "объясни мне этот термин в контексте этого протокола") он очень даже хорош.

# Что такое circuit

Circuit — это то, что можно доказать с помощью криптографических протоколов. Разработка подобных проектов является самой частой работой, которую можно найти в домене zk. 

Задача при разработке circuit состоит в том, чтобы описать алгоритм с помощью фреймворка и провалидировать переходы в вычислениях. Схема получает на вход публичные и приватные сигналы. Приватные сигналы известны только тому, кто создает доказательство.

### Пример
Возьмем простой пример — знание множителей числа: $a×b=c$. В этом примере $c$ будет публичным входом, так как его будут знать все, $а$ и $b$ будут приватными.

Каждый фреймворк описывает это по-разному. Возьмем самый популярный DSL — Circom:

```circom
pragma circom 2.0.0;

template Multiplier2 () {
   signal input a;
   signal input b;
   signal output c;

   c <== a * b;
}
component main = Multiplier2();
```

Это все! Алиса запускает этот код, он производит доказательство, а Боб может проверить доказательство, не зная $a$ и $b$.

## {on, off}-circuit

Используя DSL, сложнее совершить ошибку: у вас мало шансов сделать какой-либо логический переход без доказательств. Однако в более широком поле инструментов у вас есть {on, off}-circuit. Вычисления могут быть доказываемыми и совершаемыми вне доказательств.

#### Пример

Задача: 
$a×b  mod  N = c$ где $N$ большое простое число

Может показаться, что нужно выполнять модульные операции внутри circuit. Однако правильнее разделить числа обычным способом, получить соотношение $a×b=r×N+c$ и on-circuit доказать только это равенство, что проще и мало отличается от предыдущего примера.

### Выводы
Рекомендуем попробовать [Circom](https://docs.circom.io/getting-started/installation/) и посмотреть простые примеры. Это самый простой способ начать работать с zkp.

## Что такое halo2?
[halo2](https://github.com/zcash/halo2) — это библиотека и фреймворк для создания zk-схем на основе PLONKish арифметизации. Он позволяет описывать сложные вычисления и доказывать их корректность без раскрытия приватных данных. В отличие от некоторых DSL, halo2 предоставляет более гибкий и мощный инструментарий, но требует более глубокого понимания математики и криптографии.

## Что такое арифметизация PLONKish
Когда речь идет о halo2, мы используем [PLONKish арифметизацию](https://zcash.github.io/halo2/concepts/arithmetization.html).

В ее рамках у нас есть матрица над полем (каждый элемент матрицы — элемент конечного поля над простым числом), в которой мы:

Имеем колонки трех типов:
- Fixed — неизменные константы.
- Instance — сигналы внутрь circuit (передаваемые извне в схему).
- Advice — зависящие от сигнала значения.

Задаем отношения колонок друг к другу (Gates):
- Например, "5-я колонка плюс 4-я колонка минус 9-я колонка должно получиться 0".

Задаем допустимые значения для некоторого отношения над колонками (Lookup):
- Например, "5-я колонка плюс 4-я колонка минус 9-я колонка должно получиться что-то из 1-й колонки".

Говорим, что некоторые ячейки должны быть равны друг другу (Copy-constraint):
- Единственный тип отношений не между колонками, а между ячейками.

Все инструменты, кроме последнего, применяются на первом этапе конфигурации схемы. Чем меньше колонок, gates и lookup аргументов, тем лучше, однако их число варьируется от проекта к проекту. Можно расти в ширь, добавляя колонки, а можно вниз, стараясь минимизировать число отношений над колонками. Все это влияет на разные параметры финального решения. Таким образом, арифметизация — краеугольная тема для разработки circuit.

Итогово, ваша задача — выразить целевой алгоритм как совокупность отношений, представленных с помощью инструментов выше. Проще говоря, каждая строка матрицы — кусок вычислений, а сами вычисления задаются на колонках.

## Какую задачу мы будем решать и почему?

Мы решили взять небольшую, но исходно не математическую проблему: **проверку сбалансированности скобок в строке**. Задача включает в себя формулирование арифметизации, реализацию и тесты.

### Почему именно эту задачу?

Почти все учебные материалы по написанию circuit сделаны для математиков и про математику. Здесь же мы хотим показать, что можно решать практические задачи, не связанные напрямую с математикой, и научить разработчиков использовать zk-технологии для решения реальных проблем.

Хотя конкретна эта задача синтетическая, но легко представить подобный circuit для доказательства криптостойкости пароля, без раскрытия пароля. 

## Решение (Арифметизация)

## Алгоритм
Рассмотрим простое решение на Rust:

```rust
fn is_valid_brackets(s: &str) -> bool {
    s.chars()
        .try_fold(0u32, |acc, c| match c {
            '(' => Some(acc + 1),
            ')' => acc.checked_sub(1),
            other => panic!("not allowed symbol: {other}"),
        })
        .eq(&Some(0))
}

fn main() {
    assert!(is_valid_brackets("()"));
    assert!(!is_valid_brackets(")("));
}
```

### Математическое представление
Нам нужно представить этот алгоритм через инструменты PLONKish арифметизации.

1. Проверка допустимых символов: Нужно провалидировать, что вход состоит только из допустимых ASCII кодов (40 для '(', 41 для ')').
2. Преобразование символов: Нужна функция $f(x)$, которая преобразует 40 и 41 в 1 и -1 соответственно.
3. Суммирование: Нужно просуммировать все значения и проверить, что сумма равна 0: $∑f(x_i)=0$.
4. Проверка неперехода через ноль: Нужно убедиться, что аккумулятор (число открытых скобок) не становится отрицательным на любом шаге (иначе последовательность типа ')(' прошла бы проверку).

## Решение шаг за шагом
### 1. Проверка допустимых символов
Используем lookup таблицу. Копируем входной сигнал и проверяем, что он входит в таблицу, где заполнены только два константных значения: 40 и 41.

### 2. Преобразование символов
Нам нужна функция $f(x)$, которая для $x=40$ дает $1$, а для $x=41$ дает $-1$.

**Решение**:
Для решения подобной задачи есть [многочлен Лагранджа](https://ru.wikipedia.org/wiki/%D0%98%D0%BD%D1%82%D0%B5%D1%80%D0%BF%D0%BE%D0%BB%D1%8F%D1%86%D0%B8%D0%BE%D0%BD%D0%BD%D1%8B%D0%B9_%D0%BC%D0%BD%D0%BE%D0%B3%D0%BE%D1%87%D0%BB%D0%B5%D0%BD_%D0%9B%D0%B0%D0%B3%D1%80%D0%B0%D0%BD%D0%B6%D0%B0), однако, так как данный материал для разработчиков, я могу посоветовать им просто спросить об этом [Wolfram GPTs](https://chatgpt.com/g/g-0S5FXLyFN-wolfram), который не просто подскажет как искать его, но и сделает все за вас.

Используем полином: $f(x)=81−2x$

Проверяем:
- $f(40)=81−2×40=1$
- $f(41)=81−2×41=−1$

### 3. Суммирование
Можно создать множество колонок и сделать все за одну строку или взять пару колонок и сделать за множество строк. В общем случае, лучше расти вниз (больше строк), чем вширь (больше колонок).

Структура колонок:
| a1      | a2                    |
| --      | --                    |
| x_i     | prev_val              |
| x_{i+1} | prev_val + 81 - 2*x_i |

Таким образом, мы получили сумму всех преобразованных значений в колонке аккумулятора. В конце сравниваем с нулем, и мы выполнили этот пункт.

### 4. Проверка неперехода через ноль
Работая в поле, у нас нет отрицательных чисел (отрицательное число $-k$ представлено как $p−k$, где $p$ — характеристика поля). Также нет возможности легко сделать сравнение "больше/меньше".

**Решение**:

В целом, нам просто нужно проверить равенство на $-1$ (ведь шаг всегда на единицу), поэтому прибавим $1$ и сравним результат с нулем. Назовем $x = acc + 1$

Дизайн ограничений будет относительно простой, хоть и многословный:

| a1      | a2          | gate1           |
| ------- | ----------- | --------------- |
| x       | x' = 1/x    | x * (1 - x * x')|

Это выражение проверяет, что в a2 колонке действительно находится 1/x (или что в x точно лежит 0)

| x   | x'        | Equation              |
| --- | -------   | ------------------    |
| 0   | 0         | 0 * (1 - 0 * 0)  == 0 |
| 5   | 1/5       | 5 * (1 - 5/5)    == 0 |
| 5   | x' != 1/5 | 5 * (1 - 5 * x') != 0 |
| 0   | 5         | 5 * (1 - 0 * 5)  == 0 |

Это дает, что выражение $1 - x * x' == 0$ только в случае, когда $x != 0$, значит добавим $gate2 = 1 - x * x' == 0$ и получим доказательство того, что внутри $x$ лежит не $0$.

$gate1$ для валидации $x' = 1/x$, 
$gate2$ для валидации $x == 0$ с учетом верности $gate1$

Теперь у нас есть полный набор ограничений, необходимых для реализации circuit.

### План реализации в коде
Мы планируем реализовать наше решение в коде, используя halo2. Для этого разделим реализацию на три шага:

#### Решаем, в каком виде и как будем хранить приватный вход
- Определяем, что является публичным входом.
- Определяем крайние случаи для тестирования.
- Понимаем, что данный circuit нам дает в практическом смысле.

#### Настройка ограничений
- Выражаем gate/lookup, описанные в арифметизации, через ConstraintSystem.
- Решаем, сколько у нас будет колонок и что в них будет лежать.
- Реализуем Circuit::configure.

#### Для конкретного входа заполняем ячейки таблицы
- Ограничения, заданные ранее, не зависят от входа — это дизайн схемы.
- Данные внутри таблицы, знание которых мы и доказываем, заполняются на этом этапе.
- Реализуем Circuit::synthesize.

## Создаем проект:

```bash
cargo init --lib halo2-workshop
cd halo2-workshop
cargo add halo2_proofs
```

